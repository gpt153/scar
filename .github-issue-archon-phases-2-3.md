# Implement Automatic Research Workflow (Archon Phase 2 & 3)

## Overview

Build and evaluate automatic research capabilities that leverage Archon's knowledge base for zero-touch documentation access. This extends Phase 1 (manual `/crawl` commands) with intelligent auto-detection and PIV loop integration.

## Background

Phase 1 (‚úÖ completed in #TBD) added manual crawl commands. Now we need automatic workflows:
- **Phase 2**: Orchestrator detects research needs and auto-crawls
- **Phase 3**: PIV loop commands (prime/plan/execute) search Archon first

## User Story

As a SCAR user, I want the system to automatically detect when external documentation is needed and index it proactively, so that I never have to manually research dependencies and AI responses are always accurate and complete.

## Desired Workflow

```
User: "Implement Supabase real-time subscriptions"
‚Üì
Orchestrator detects "Supabase" mention
‚Üì
Checks Archon: docs.supabase.com indexed? NO
‚Üì
Evaluates: "Is this valuable cross-project knowledge?" YES
‚Üì
Auto-discovers best docs URL: https://supabase.com/docs
‚Üì
Triggers background crawl (non-blocking)
‚Üì
Optionally waits for completion or proceeds with partial knowledge
‚Üì
AI responds using freshly indexed Supabase documentation
‚Üì
Future conversations: Supabase knowledge already available ‚úÖ
```

## Phase 2: Orchestrator Auto-Detection

### Components to Build

1. **Dependency Detector** (`src/utils/dependency-detector.ts`)
   - Parse user prompts for external dependencies
   - Database of known frameworks/libraries with docs URLs
   - Pattern matching: "react", "supabase", "fastapi", etc.
   - Return: `{ name, docsUrl, category }`

2. **Knowledge Evaluator**
   - Determine if dependency is worth indexing
   - Criteria: popularity, cross-project value, stability
   - Blocklist: internal tools, deprecated libraries

3. **Orchestrator Integration** (`src/orchestrator/orchestrator.ts`)
   - Hook: Before sending prompt to AI
   - Check Archon for existing docs (via `/api/knowledge-items/sources`)
   - If missing + valuable ‚Üí trigger crawl
   - Options: block until complete vs. proceed with partial knowledge

4. **User Notifications**
   - "üîç Detected Supabase dependency - indexing documentation..."
   - "‚úÖ Supabase docs indexed (234 pages) - responding with full context"
   - "‚è≥ Crawling in background - response may improve on retry"

### Configuration

```env
# Phase 2 settings
ARCHON_AUTO_CRAWL=true              # Enable automatic crawling
ARCHON_CRAWL_STRATEGY=background    # background | blocking | suggest
ARCHON_CRAWL_MAX_WAIT=60000        # Max wait time for blocking crawls (ms)
```

**Crawl Strategies**:
- `background`: Start crawl, don't wait, respond immediately
- `blocking`: Wait for crawl completion before responding (with timeout)
- `suggest`: Ask user "Index Supabase docs? (y/n)" before crawling

## Phase 3: PIV Loop Integration

### Commands to Enhance

1. **`/prime` Enhancement** (`.claude/commands/exp-piv-loop/prime.md`)
   ```
   Step 0: Check Archon Knowledge Base
   - Query: rag_get_available_sources()
   - Search: rag_search_knowledge_base(query="[PROJECT_NAME]")
   - Report: "Found 3 indexed dependencies: React, PostgreSQL, FastAPI"

   Step 1: Analyze Codebase Structure
   [... existing prime logic ...]

   Step 2: Identify Knowledge Gaps
   - Compare package.json/requirements.txt with Archon sources
   - Missing docs ‚Üí recommend: "Run /crawl https://docs.example.com"
   - Or auto-crawl if ARCHON_AUTO_CRAWL=true
   ```

2. **`/plan` Enhancement** (`.claude/commands/exp-piv-loop/plan.md`)
   ```
   Phase 3: External Research & Documentation

   Before web search, check Archon:
   - rag_search_knowledge_base(query="[feature type] best practices")
   - rag_search_code_examples(query="[similar implementation]")

   Include Archon references in plan:
   - "See: Supabase Real-time Docs (Archon) - Section: Broadcast"
   ```

3. **`/execute` Enhancement** (`.claude/commands/exp-piv-loop/execute.md`)
   ```
   During implementation, prefer Archon over web search:
   - Check Archon first for API references
   - Fall back to WebSearch only if not found
   - Update plan with Archon source citations
   ```

### MCP Integration

These enhancements use existing Archon MCP tools:
- ‚úÖ `rag_get_available_sources()` - Already enabled
- ‚úÖ `rag_search_knowledge_base()` - Already enabled
- ‚úÖ `rag_search_code_examples()` - Already enabled

No new MCP setup required (already configured in Phase 1).

## Testing Strategy

### Unit Tests

**Dependency Detector**:
```typescript
// src/utils/dependency-detector.test.ts
test('detects React mention', () => {
  const deps = detectDependencies("Use React hooks for state");
  expect(deps).toContainEqual({
    name: 'React',
    docsUrl: 'https://react.dev',
    category: 'framework'
  });
});

test('ignores internal tools', () => {
  const deps = detectDependencies("Use our internal auth-lib");
  expect(deps).toHaveLength(0);
});
```

**Knowledge Evaluator**:
```typescript
test('values popular stable libraries', () => {
  expect(isWorthIndexing('react')).toBe(true);
  expect(isWorthIndexing('deprecated-lib')).toBe(false);
});
```

### Integration Tests

**Auto-Crawl Flow**:
```bash
# Setup: Archon running, ARCHON_AUTO_CRAWL=true

# Test 1: First mention triggers crawl
curl -X POST http://localhost:3000/test/message \
  -d '{"conversationId":"test-auto","message":"How do I use Supabase?"}'

# Expected:
# - Message: "üîç Detected Supabase - indexing docs..."
# - Archon receives crawl request
# - Knowledge indexed before response (blocking mode)

# Test 2: Second mention uses cached knowledge
curl -X POST http://localhost:3000/test/message \
  -d '{"conversationId":"test-auto-2","message":"Supabase real-time setup?"}'

# Expected:
# - No crawl triggered (docs already exist)
# - Response includes Archon citations
```

**PIV Loop Flow**:
```bash
# Test: Prime command searches Archon first
curl -X POST http://localhost:3000/test/message \
  -d '{"conversationId":"test-piv","message":"/command-invoke prime"}'

# Expected in output:
# "Step 0: Checking Archon knowledge base..."
# "Found: React (3,456 chunks), PostgreSQL (1,234 chunks)"
# "Missing: Grammy (Telegram bot framework)"
# "Recommendation: Run /crawl https://grammy.dev/guide/"
```

### Manual Validation

**Scenario 1: New dependency in prompt**
```
User: "Add Stripe payment integration"
Expected:
1. Bot: "üîç Detected Stripe dependency - indexing documentation..."
2. Crawl starts: https://stripe.com/docs
3. Progress updates (if blocking mode)
4. Bot: "‚úÖ Stripe docs indexed - responding with full context"
5. Response includes accurate Stripe API usage
```

**Scenario 2: Prime with missing docs**
```
User: /command-invoke prime
Expected:
1. Bot analyzes package.json
2. Bot: "Checking Archon knowledge base..."
3. Bot: "Found: React, Express"
4. Bot: "Missing: discord.js"
5. Bot: "Recommendation: /crawl https://discord.js.org/docs"
6. User runs recommended command
7. Next prime: All dependencies indexed ‚úÖ
```

**Scenario 3: Plan with Archon references**
```
User: /command-invoke plan "Add real-time notifications"
Expected in plan:
- "See: Supabase Real-time Docs (Archon) - Broadcast section"
- "Code example from Socket.io Docs (Archon) - Event handling"
- References include [Archon] tag for traceability
```

## Acceptance Criteria

### Phase 2 (Orchestrator)
- [ ] `src/utils/dependency-detector.ts` implemented with 20+ known dependencies
- [ ] Auto-crawl triggers when unknown dependency mentioned
- [ ] User sees clear notifications about crawl status
- [ ] Three crawl strategies work correctly (background, blocking, suggest)
- [ ] Configuration via environment variables
- [ ] Duplicate crawl prevention (check existing sources)
- [ ] Unit tests: 95%+ coverage for detector and evaluator
- [ ] Integration tests: All 3 strategies validated

### Phase 3 (PIV Loop)
- [ ] `/prime` searches Archon before codebase analysis
- [ ] `/prime` recommends missing docs for crawling
- [ ] `/plan` includes Archon references in external research section
- [ ] `/execute` prefers Archon over WebSearch
- [ ] All commands document Archon sources used
- [ ] Integration tests: Prime ‚Üí Plan ‚Üí Execute flow validated
- [ ] Manual validation: All 3 scenarios pass

### Both Phases
- [ ] Zero breaking changes to Phase 1 functionality
- [ ] All existing tests still pass
- [ ] Type checking: 0 errors
- [ ] Linting: 0 errors
- [ ] Documentation updated (CLAUDE.md, docs/archon-integration.md)
- [ ] Performance: Auto-crawl adds <2s latency in background mode
- [ ] Error handling: Graceful degradation if Archon unavailable

## Implementation Plan

### Step 1: Build Dependency Detector (Phase 2 Foundation)
- Create `src/utils/dependency-detector.ts`
- Database of 30+ common dependencies
- Pattern matching and keyword detection
- Unit tests with 100% coverage
- **Estimate**: 3-4 hours

### Step 2: Orchestrator Integration (Phase 2 Core)
- Modify `src/orchestrator/orchestrator.ts`
- Add pre-prompt hook for dependency detection
- Implement 3 crawl strategies
- Add user notifications
- Integration tests
- **Estimate**: 6-8 hours

### Step 3: PIV Loop Enhancement (Phase 3)
- Update `.claude/commands/exp-piv-loop/prime.md`
- Update `.claude/commands/exp-piv-loop/plan.md`
- Update `.claude/commands/exp-piv-loop/execute.md`
- Add Archon search steps
- Test with real PIV workflow
- **Estimate**: 4-6 hours

### Step 4: Validation & Documentation
- Manual testing of all scenarios
- Performance benchmarking
- Documentation updates
- Create usage examples
- **Estimate**: 2-3 hours

**Total Estimate**: 15-21 hours (2-3 days)

## Success Metrics

**Quantitative**:
- Auto-crawl accuracy: >90% (correct dependency detection)
- False positive rate: <5% (unnecessary crawls)
- Response time: <2s additional latency (background mode)
- Knowledge reuse: >50% of requests use pre-indexed docs

**Qualitative**:
- User never manually searches external docs
- AI responses more accurate (measurable via user feedback)
- Cross-project knowledge sharing works seamlessly
- System feels "intelligent" and proactive

## Risks & Mitigations

**Risk**: Auto-crawl spam (too aggressive)
- **Mitigation**: Blocklist, evaluation logic, rate limiting

**Risk**: Bad URLs or broken sites
- **Mitigation**: Timeout handling, graceful failures, user override

**Risk**: Performance degradation (blocking crawls too slow)
- **Mitigation**: Default to background mode, configurable timeouts

**Risk**: Archon unavailable
- **Mitigation**: Graceful degradation, fall back to WebSearch

## Related Work

- ‚úÖ Phase 1: Manual crawl commands (#TBD)
- üìÑ Complete spec: `docs/archon-integration.md`
- üìÑ Implementation plan: `.agents/plans/archon-rest-api-client.md`

## Questions for Discussion

1. **Crawl strategy default**: Should we default to `background`, `blocking`, or `suggest`?
2. **User control**: Should users be able to disable auto-crawl per-conversation?
3. **Crawl limits**: Max crawls per hour? Max depth per auto-crawl?
4. **Knowledge expiry**: Re-crawl stale docs automatically? (e.g., after 30 days)
5. **Privacy**: Should we track which dependencies users commonly need?

---

**Complexity**: High (architecture changes + PIV loop modifications)
**Priority**: Medium (Phase 1 provides manual workaround)
**Dependencies**: Phase 1 must be deployed and stable
**Type**: Enhancement
**Labels**: `enhancement`, `archon`, `phase-2`, `phase-3`, `automation`
